## 2024-05-24 - Weak Session Token Entropy
**Vulnerability:** Session tokens were generated by truncating a UUID v4 to 8 characters (`[..8]`), providing only 32 bits of entropy ($16^8$), which is vulnerable to brute-force attacks on a local network.
**Learning:** Developers often truncate UUIDs for brevity/UX without realizing the massive reduction in security. A full UUID (128 bits) is necessary for unauthenticated session identifiers.
**Prevention:** Always use the full entropy of the random source. Use `Uuid::simple()` to get a clean 32-character hex string if hyphens are undesirable, but never truncate randomness used for security tokens.
## 2026-01-11 - Permissive CORS on Local Server
**Vulnerability:** The HTTP server included `CorsLayer::new().allow_origin(Any)`, allowing any website (including malicious ones) to make requests to the local file sharing server via the user's browser.
**Learning:** Local servers often blindly copy CORS middleware from web examples. For servers where the frontend is embedded/served from the same origin, CORS is usually unnecessary and only serves to weaken security.
**Prevention:** Default to NO CORS headers. Only add them if explicitly needed for a specific cross-origin use case. If needed, never use `Any` (`*`) for a local server with authentication tokens.
## 2025-10-31 - Insecure File Permissions on Creation
**Vulnerability:** Files received via upload were created using `File::create`, which defaults to system umask (often `0o644` or `0o666`), making sensitive files readable by other local users.
**Learning:** Standard file creation methods prioritize convenience over security. For privacy-focused applications, default permissions are often too permissive.
**Prevention:** Use `OpenOptions` with `.mode(0o600)` on Unix systems to explicitly restrict permissions to the owner only upon file creation.
## 2026-05-27 - Unbounded State DoS in WebSocket Handlers
**Vulnerability:** The WebSocket upload handler allowed unlimited concurrent "pending" upload requests to accumulate in memory before user approval, allowing a malicious client to exhaust server resources.
**Learning:** Async services waiting for user interaction (like file acceptance) must have strict concurrency limits, as "pending" states consume memory and file descriptors.
**Prevention:** Enforce `MAX_PENDING_REQUESTS` limits on any stateful tracking map. Reject new requests immediately when the limit is reached.
## 2026-01-12 - Unbounded Pending State DoS
**Vulnerability:** The WebSocket handler stored pending upload requests in an unbounded `HashMap`, allowing an attacker to exhaust server memory or flood the user interface by initiating thousands of handshake requests without completing them.
**Learning:** Async state management often overlooks the "waiting" state. Any state that waits for user interaction (like approval) must have a strict upper bound to prevent resource exhaustion.
**Prevention:** Enforce hard limits on all state collections that can be influenced by external clients, especially those involving human-speed timeouts (e.g., waiting for user approval).
## 2026-05-27 - Use-After-Move in Async Helper Error Handling
**Vulnerability:** A `try_add_request` helper method consumed a `oneshot::Sender` by value but failed to return it on error. The calling code attempted to use the sender in a fallback error handling path, leading to a compilation error (and potential logic bug if it were `Copy`).
**Learning:** Async helper methods that consume resources (like channels) must be carefully designed. If the resource is needed for error handling in the caller, the helper should return it or handle the error internally.
**Prevention:** Encapsulate state mutations fully within the helper method. If a check fails (e.g., DoS limit), the helper should handle the rejection or return a result type that clearly indicates ownership status. Avoid "check-then-insert" patterns where ownership is split.
## 2026-06-03 - Inline Scripts preventing Strict CSP in Embedded Servers
**Vulnerability:** The embedded web interface utilized inline JavaScript, necessitating the use of `'unsafe-inline'` in the Content Security Policy (CSP), thereby increasing susceptibility to Cross-Site Scripting (XSS).
**Learning:** In single-binary applications using `include_str!`, developers often default to inlining all assets for simplicity, neglecting the security benefits of separating concerns to enable strict CSP.
**Prevention:** Separate JavaScript and CSS into distinct files even in embedded servers. Serve them via dedicated routes and embed them individually to enable `script-src 'self'` and eliminate XSS vectors.
## 2026-06-15 - Insecure P2P File Creation
**Vulnerability:** The P2P transfer module created received files using `File::create`, which does not set restrictive permissions (e.g., 0o600), leaving downloaded files readable by other local users on Unix systems.
**Learning:** Security fixes applied to one module (like `http_share`) are often missed in parallel implementations (like `transfer`). "Secure by default" wrappers should be shared across the entire codebase.
**Prevention:** Create centralized security helper functions (like `open_secure_file`) in a shared utility module and enforce their usage across all file creation paths, rather than duplicating logic.
## 2026-06-03 - Unlimited Verification Attempts in Async Handshake
**Vulnerability:** The pairing verification handshake allowed unlimited concurrent attempts. Since the 4-digit code is generated per session, an attacker could spawn thousands of concurrent connections to brute-force the code by statistical probability or resource exhaustion.
**Learning:** Short codes (like 4-digit PINs) rely entirely on rate limiting for security. In an async server, "concurrency" is the enemy of rate limiting if not explicitly managed. Generating a new code per connection does not protect against brute force if the attacker can open enough connections to guess one correctly.
**Prevention:** Implement strict global concurrency limits for sensitive handshakes using atomic counters or semaphores. Combine this with artificial delays to drastically reduce the effective guess rate.
## 2026-06-18 - Unbounded File Write in WebSocket Upload
**Vulnerability:** The WebSocket upload handler trusted the client's data stream implicitly. A malicious client could declare a small file size but send a massive amount of data, causing the server to write more bytes than declared to disk, leading to integrity violations and potential disk exhaustion.
**Learning:** In stream-based protocols (like WebSockets), never trust the client to stop sending data when the declared size is reached. Always calculate remaining bytes and strictly enforce the limit on the server side by truncating or rejecting excess data.
**Prevention:** Track `received_bytes` against `expected_size` on every chunk. Use `saturating_sub` to calculate remaining allowance and slice incoming buffers to ensure no more than `remaining` bytes are ever written.
