## 2024-05-23 - Rust Path Sanitization Pitfalls
**Vulnerability:** Relied on `std::path::Path::new(path).file_name()` for filename sanitization in a cross-platform context.
**Learning:** `Path::new` behavior is OS-dependent. On Linux, `\` is treated as a valid filename character, not a separator. If a Windows client sends `..\..\evil.exe`, a Linux server might accept it as a filename containing backslashes, or fail to strip the directory traversal components if it expected `/`. Conversely, web inputs might mix separators.
**Prevention:** For network inputs, always manually sanitize filenames by treating both `/` and `\` as separators and filtering control characters, rather than relying on the host OS's `Path` implementation.
## 2024-05-24 - Weak Session Token Entropy
**Vulnerability:** Session tokens were generated by truncating a UUID v4 to 8 characters (`[..8]`), providing only 32 bits of entropy ($16^8$), which is vulnerable to brute-force attacks on a local network.
**Learning:** Developers often truncate UUIDs for brevity/UX without realizing the massive reduction in security. A full UUID (128 bits) is necessary for unauthenticated session identifiers.
**Prevention:** Always use the full entropy of the random source. Use `Uuid::simple()` to get a clean 32-character hex string if hyphens are undesirable, but never truncate randomness used for security tokens.
## 2026-01-11 - Permissive CORS on Local Server
**Vulnerability:** The HTTP server included `CorsLayer::new().allow_origin(Any)`, allowing any website (including malicious ones) to make requests to the local file sharing server via the user's browser.
**Learning:** Local servers often blindly copy CORS middleware from web examples. For servers where the frontend is embedded/served from the same origin, CORS is usually unnecessary and only serves to weaken security.
**Prevention:** Default to NO CORS headers. Only add them if explicitly needed for a specific cross-origin use case. If needed, never use `Any` (`*`) for a local server with authentication tokens.
## 2025-10-31 - Insecure File Permissions on Creation
**Vulnerability:** Files received via upload were created using `File::create`, which defaults to system umask (often `0o644` or `0o666`), making sensitive files readable by other local users.
**Learning:** Standard file creation methods prioritize convenience over security. For privacy-focused applications, default permissions are often too permissive.
**Prevention:** Use `OpenOptions` with `.mode(0o600)` on Unix systems to explicitly restrict permissions to the owner only upon file creation.
## 2026-05-27 - Unbounded State DoS in WebSocket Handlers
**Vulnerability:** The WebSocket upload handler allowed unlimited concurrent "pending" upload requests to accumulate in memory before user approval, allowing a malicious client to exhaust server resources.
**Learning:** Async services waiting for user interaction (like file acceptance) must have strict concurrency limits, as "pending" states consume memory and file descriptors.
**Prevention:** Enforce `MAX_PENDING_REQUESTS` limits on any stateful tracking map. Reject new requests immediately when the limit is reached.
## 2026-01-12 - Unbounded Pending State DoS
**Vulnerability:** The WebSocket handler stored pending upload requests in an unbounded `HashMap`, allowing an attacker to exhaust server memory or flood the user interface by initiating thousands of handshake requests without completing them.
**Learning:** Async state management often overlooks the "waiting" state. Any state that waits for user interaction (like approval) must have a strict upper bound to prevent resource exhaustion.
**Prevention:** Enforce hard limits on all state collections that can be influenced by external clients, especially those involving human-speed timeouts (e.g., waiting for user approval).
## 2026-05-27 - Use-After-Move in Async Helper Error Handling
**Vulnerability:** A `try_add_request` helper method consumed a `oneshot::Sender` by value but failed to return it on error. The calling code attempted to use the sender in a fallback error handling path, leading to a compilation error (and potential logic bug if it were `Copy`).
**Learning:** Async helper methods that consume resources (like channels) must be carefully designed. If the resource is needed for error handling in the caller, the helper should return it or handle the error internally.
**Prevention:** Encapsulate state mutations fully within the helper method. If a check fails (e.g., DoS limit), the helper should handle the rejection or return a result type that clearly indicates ownership status. Avoid "check-then-insert" patterns where ownership is split.
## 2026-06-03 - Inline Scripts preventing Strict CSP in Embedded Servers
**Vulnerability:** The embedded web interface utilized inline JavaScript, necessitating the use of `'unsafe-inline'` in the Content Security Policy (CSP), thereby increasing susceptibility to Cross-Site Scripting (XSS).
**Learning:** In single-binary applications using `include_str!`, developers often default to inlining all assets for simplicity, neglecting the security benefits of separating concerns to enable strict CSP.
**Prevention:** Separate JavaScript and CSS into distinct files even in embedded servers. Serve them via dedicated routes and embed them individually to enable `script-src 'self'` and eliminate XSS vectors.
## 2026-06-15 - Insecure P2P File Creation
**Vulnerability:** The P2P transfer module created received files using `File::create`, which does not set restrictive permissions (e.g., 0o600), leaving downloaded files readable by other local users on Unix systems.
**Learning:** Security fixes applied to one module (like `http_share`) are often missed in parallel implementations (like `transfer`). "Secure by default" wrappers should be shared across the entire codebase.
**Prevention:** Create centralized security helper functions (like `open_secure_file`) in a shared utility module and enforce their usage across all file creation paths, rather than duplicating logic.
## 2026-06-03 - Unlimited Verification Attempts in Async Handshake
**Vulnerability:** The pairing verification handshake allowed unlimited concurrent attempts. Since the 4-digit code is generated per session, an attacker could spawn thousands of concurrent connections to brute-force the code by statistical probability or resource exhaustion.
**Learning:** Short codes (like 4-digit PINs) rely entirely on rate limiting for security. In an async server, "concurrency" is the enemy of rate limiting if not explicitly managed. Generating a new code per connection does not protect against brute force if the attacker can open enough connections to guess one correctly.
**Prevention:** Implement strict global concurrency limits for sensitive handshakes using atomic counters or semaphores. Combine this with artificial delays to drastically reduce the effective guess rate.

## 2026-01-26 - WebSocket Upload Stream Overflow
**Vulnerability:** The WebSocket upload handler trusted the declared `file_size` for loop termination but wrote the full content of incoming chunks to disk. An attacker could declare a small size but send large chunks, causing the server to write more data than permitted before the check triggered.
**Learning:** In streaming data handlers, checking limits *after* processing a chunk is insufficient. Data must be sliced or validated *before* being written to persistent storage or processed.
**Prevention:** Always calculate `remaining_bytes` and slice the input buffer (`min(chunk_size, remaining)`) before performing any write operations.

## 2026-06-25 - Distributed Security Constants
**Vulnerability:** Limits like `MAX_FILE_SIZE` were defined locally in the `http_share` module, leaving the P2P `transfer` module vulnerable to DoS attacks (disk exhaustion) as it lacked similar checks.
**Learning:** Security constants (limits, timeouts) should be centralized, not module-specific. Parallel implementations of similar features (e.g., HTTP upload vs P2P transfer) often miss applying the same security controls.
**Prevention:** Define global security constants in a shared `constants` module and enforce their usage across all relevant modules. Use shared validation helpers where possible.

## 2026-06-25 - Information Disclosure in WebSocket Messages
**Vulnerability:** The `ServerMessage::Complete` WebSocket message returned the full absolute path of the saved file to the client (`saved_path`), exposing the server's directory structure and username.
**Learning:** Developers often return full object state (like paths) for debugging convenience or "completeness", forgetting that this data crosses a trust boundary to the client.
**Prevention:** Review all data structures sent to clients (DTOs). Only include fields that are strictly necessary for the client's operation. Never include internal server paths.

## 2026-06-25 - Unbounded Active State Resource Exhaustion
**Vulnerability:** While pending uploads were limited, the system had no limit on the number of *active* concurrent uploads. An attacker could initiate many uploads, wait for acceptance, and then stall the transfers, exhausting server resources (file descriptors, memory).
**Learning:** Limiting the "queue" (pending state) is not enough. The "processing" state (active) also consumes resources and must be bounded, especially when handling long-running operations like file transfers.
**Prevention:** Implement distinct concurrency limits for both pending and active states. Use atomic counters or semaphores to enforce global limits on active processing tasks.
## 2026-07-09 - DoS via Unbounded Length Prefix
**Vulnerability:** The custom P2P protocol read a 4-byte length prefix and immediately allocated a buffer of that size (`vec![0u8; len]`), allowing an attacker to cause an Out-Of-Memory (OOM) crash by sending a 4GB length claim.
**Learning:** Never allocate memory based solely on untrusted input size. Even if you "read" the size, the sender can lie. This is a classic DoS vector in binary protocols.
**Prevention:** Enforce a strict `MAX_MSG_SIZE` limit (e.g., 64KB) *before* performing any allocation based on a length prefix read from the network.
