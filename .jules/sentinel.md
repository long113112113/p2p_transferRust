## 2024-05-24 - Weak Session Token Entropy
**Vulnerability:** Session tokens were generated by truncating a UUID v4 to 8 characters (`[..8]`), providing only 32 bits of entropy ($16^8$), which is vulnerable to brute-force attacks on a local network.
**Learning:** Developers often truncate UUIDs for brevity/UX without realizing the massive reduction in security. A full UUID (128 bits) is necessary for unauthenticated session identifiers.
**Prevention:** Always use the full entropy of the random source. Use `Uuid::simple()` to get a clean 32-character hex string if hyphens are undesirable, but never truncate randomness used for security tokens.
## 2026-01-11 - Permissive CORS on Local Server
**Vulnerability:** The HTTP server included `CorsLayer::new().allow_origin(Any)`, allowing any website (including malicious ones) to make requests to the local file sharing server via the user's browser.
**Learning:** Local servers often blindly copy CORS middleware from web examples. For servers where the frontend is embedded/served from the same origin, CORS is usually unnecessary and only serves to weaken security.
**Prevention:** Default to NO CORS headers. Only add them if explicitly needed for a specific cross-origin use case. If needed, never use `Any` (`*`) for a local server with authentication tokens.
## 2026-01-12 - Unbounded Pending State DoS
**Vulnerability:** The WebSocket handler stored pending upload requests in an unbounded `HashMap`, allowing an attacker to exhaust server memory or flood the user interface by initiating thousands of handshake requests without completing them.
**Learning:** Async state management often overlooks the "waiting" state. Any state that waits for user interaction (like approval) must have a strict upper bound to prevent resource exhaustion.
**Prevention:** Enforce hard limits on all state collections that can be influenced by external clients, especially those involving human-speed timeouts (e.g., waiting for user approval).
