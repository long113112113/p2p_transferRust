## 2024-05-24 - Weak Session Token Entropy
**Vulnerability:** Session tokens were generated by truncating a UUID v4 to 8 characters (`[..8]`), providing only 32 bits of entropy ($16^8$), which is vulnerable to brute-force attacks on a local network.
**Learning:** Developers often truncate UUIDs for brevity/UX without realizing the massive reduction in security. A full UUID (128 bits) is necessary for unauthenticated session identifiers.
**Prevention:** Always use the full entropy of the random source. Use `Uuid::simple()` to get a clean 32-character hex string if hyphens are undesirable, but never truncate randomness used for security tokens.
## 2026-01-11 - Permissive CORS on Local Server
**Vulnerability:** The HTTP server included `CorsLayer::new().allow_origin(Any)`, allowing any website (including malicious ones) to make requests to the local file sharing server via the user's browser.
**Learning:** Local servers often blindly copy CORS middleware from web examples. For servers where the frontend is embedded/served from the same origin, CORS is usually unnecessary and only serves to weaken security.
**Prevention:** Default to NO CORS headers. Only add them if explicitly needed for a specific cross-origin use case. If needed, never use `Any` (`*`) for a local server with authentication tokens.
## 2025-10-31 - Insecure File Permissions on Creation
**Vulnerability:** Files received via upload were created using `File::create`, which defaults to system umask (often `0o644` or `0o666`), making sensitive files readable by other local users.
**Learning:** Standard file creation methods prioritize convenience over security. For privacy-focused applications, default permissions are often too permissive.
**Prevention:** Use `OpenOptions` with `.mode(0o600)` on Unix systems to explicitly restrict permissions to the owner only upon file creation.
## 2026-05-27 - Unbounded State DoS in WebSocket Handlers
**Vulnerability:** The WebSocket upload handler allowed unlimited concurrent "pending" upload requests to accumulate in memory before user approval, allowing a malicious client to exhaust server resources.
**Learning:** Async services waiting for user interaction (like file acceptance) must have strict concurrency limits, as "pending" states consume memory and file descriptors.
**Prevention:** Enforce `MAX_PENDING_REQUESTS` limits on any stateful tracking map. Reject new requests immediately when the limit is reached.
## 2026-01-12 - Unbounded Pending State DoS
**Vulnerability:** The WebSocket handler stored pending upload requests in an unbounded `HashMap`, allowing an attacker to exhaust server memory or flood the user interface by initiating thousands of handshake requests without completing them.
**Learning:** Async state management often overlooks the "waiting" state. Any state that waits for user interaction (like approval) must have a strict upper bound to prevent resource exhaustion.
**Prevention:** Enforce hard limits on all state collections that can be influenced by external clients, especially those involving human-speed timeouts (e.g., waiting for user approval).
## 2026-05-27 - Use-After-Move in Async Helper Error Handling
**Vulnerability:** A `try_add_request` helper method consumed a `oneshot::Sender` by value but failed to return it on error. The calling code attempted to use the sender in a fallback error handling path, leading to a compilation error (and potential logic bug if it were `Copy`).
**Learning:** Async helper methods that consume resources (like channels) must be carefully designed. If the resource is needed for error handling in the caller, the helper should return it or handle the error internally.
**Prevention:** Encapsulate state mutations fully within the helper method. If a check fails (e.g., DoS limit), the helper should handle the rejection or return a result type that clearly indicates ownership status. Avoid "check-then-insert" patterns where ownership is split.
## 2026-06-03 - Inline Scripts preventing Strict CSP in Embedded Servers
**Vulnerability:** The embedded web interface utilized inline JavaScript, necessitating the use of `'unsafe-inline'` in the Content Security Policy (CSP), thereby increasing susceptibility to Cross-Site Scripting (XSS).
**Learning:** In single-binary applications using `include_str!`, developers often default to inlining all assets for simplicity, neglecting the security benefits of separating concerns to enable strict CSP.
**Prevention:** Separate JavaScript and CSS into distinct files even in embedded servers. Serve them via dedicated routes and embed them individually to enable `script-src 'self'` and eliminate XSS vectors.
